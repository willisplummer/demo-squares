{"version":3,"sources":["node_modules/callbag-for-each/readme.js","node_modules/callbag-from-obs/readme.js","node_modules/callbag-from-iter/index.js","node_modules/callbag-from-event/index.js","node_modules/callbag-from-promise/index.js","node_modules/callbag-interval/index.js","node_modules/callbag-map/readme.js","node_modules/callbag-scan/readme.js","node_modules/callbag-flatten/index.js","node_modules/callbag-take/index.js","node_modules/callbag-skip/index.js","node_modules/callbag-filter/readme.js","node_modules/callbag-merge/readme.js","node_modules/callbag-concat/readme.js","node_modules/callbag-combine/readme.js","node_modules/callbag-share/index.js","node_modules/callbag-pipe/readme.js","node_modules/callbag-basics/index.js","squares.js","nav.js","index.js"],"names":["COLORS","SQUARE_COUNT","squares","document","getElementById","addRow","parent","rowCount","row","createElement","setAttribute","testSquare","Array","fill","undefined","forEach","_","i","newSquare","cloneNode","idNumber","appendChild","addRows","rowsToAdd","squareIds","map","rgbToHex","rgb","test","match","hex","x","parseInt","toString","slice","setBackgroundColor","id","random","Math","el","backgroundColor","style","otherColors","filter","c","newColor","floor","length","includes","ev","target","PAGE_IDS","pageButtonClasses","setHash","window","location","hash","displayContent","substr","classList","remove","add","split"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","file":"demo-squares.a67a96da.map","sourceRoot":"..","sourcesContent":["/**\n * callbag-for-each\n * ----------------\n *\n * Callbag sink that consume both pullable and listenable sources. When called\n * on a pullable source, it will iterate through its data. When called on a\n * listenable source, it will observe its data.\n *\n * `npm install callbag-for-each`\n *\n * Examples\n * --------\n *\n * Consume a pullable source:\n *\n *     const fromIter = require('callbag-from-iter');\n *     const forEach = require('callbag-for-each');\n *\n *     const source = fromIter([10,20,30,40])\n *\n *     forEach(x => console.log(x))(source); // 10\n *                                           // 20\n *                                           // 30\n *                                           // 40\n *\n * Consume a listenable source:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *\n *     const source = interval(1000);\n *\n *     forEach(x => console.log(x))(source); // 0\n *                                           // 1\n *                                           // 2\n *                                           // 3\n *                                           // ...\n */\n\nconst forEach = operation => source => {\n  let talkback;\n  source(0, (t, d) => {\n    if (t === 0) talkback = d;\n    if (t === 1) operation(d);\n    if (t === 1 || t === 0) talkback(1);\n  });\n};\n\nmodule.exports = forEach;\n","/**\n * callbag-from-obs\n * --------------\n *\n * Convert an observable (or subscribable) to a callbag listenable source.\n *\n * `npm install callbag-from-obs`\n *\n * Example:\n *\n * Convert an RxJS Observable:\n *\n *     const Rx = require('rxjs');\n *     const fromObs = require('callbag-from-obs');\n *     const observe = require('callbag-observe');\n *\n *     const source = fromObs(Rx.Observable.interval(1000).take(4));\n *\n *     observe(x => console.log(x)(source); // 0\n *                                          // 1\n *                                          // 2\n *                                          // 3\n *\n * Convert anything that has the `.subscribe` method:\n *\n *     const fromObs = require('callbag-from-obs');\n *     const observe = require('callbag-observe');\n *\n *     const subscribable = {\n *       subscribe: (observer) => {\n *         let i = 0;\n *         setInterval(() => observer.next(i++), 1000);\n *       }\n *     };\n *\n *     const source = fromObs(subscribable);\n *\n *     observe(x => console.log(x))(source); // 0\n *                                           // 1\n *                                           // 2\n *                                           // 3\n *                                           // ...\n */\n\nconst fromObs = observable => (start, sink) => {\n  if (start !== 0) return;\n  let dispose;\n  sink(0, t => {\n    if (t === 2 && dispose) {\n      if (dispose.unsubscribe) dispose.unsubscribe();\n      else dispose();\n    }\n  });\n  dispose = observable.subscribe({\n    next: x => sink(1, x),\n    error: e => sink(2, e),\n    complete: () => sink(2)\n  });\n};\n\nmodule.exports = fromObs;\n","const fromIter = iter => (start, sink) => {\n  if (start !== 0) return;\n  const iterator =\n    typeof Symbol !== 'undefined' && iter[Symbol.iterator]\n      ? iter[Symbol.iterator]()\n      : iter;\n  let inloop = false;\n  let got1 = false;\n  let res;\n  function loop() {\n    inloop = true;\n    while (got1) {\n      got1 = false;\n      res = iterator.next();\n      if (res.done) sink(2);\n      else sink(1, res.value);\n    }\n    inloop = false;\n  }\n  sink(0, t => {\n    if (t === 1) {\n      got1 = true;\n      if (!inloop && !(res && res.done)) loop();\n    }\n  });\n};\n\nmodule.exports = fromIter;\n","const fromEvent = (node, name) => (start, sink) => {\n  if (start !== 0) return;\n  const handler = ev => sink(1, ev);\n  sink(0, t => {\n    if (t === 2) node.removeEventListener(name, handler);\n  });\n  node.addEventListener(name, handler);\n};\n\nmodule.exports = fromEvent;\n","const fromPromise = promise => (start, sink) => {\n  if (start !== 0) return;\n  let ended = false;\n  const onfulfilled = val => {\n    if (ended) return;\n    sink(1, val);\n    sink(2);\n  };\n  const onrejected = err => {\n    if (ended) return;\n    sink(2, err);\n  };\n  promise.then(onfulfilled, onrejected);\n  sink(0, t => {\n    if (t === 2) ended = true;\n  });\n};\n\nmodule.exports = fromPromise;\n","const interval = period => (start, sink) => {\n  if (start !== 0) return;\n  let i = 0;\n  const id = setInterval(() => {\n    sink(1, i++);\n  }, period);\n  sink(0, t => {\n    if (t === 2) clearInterval(id);\n  });\n};\n\nmodule.exports = interval;\n","/**\n * callbag-map\n * -----------\n *\n * Callbag operator that applies a transformation on data passing through it.\n * Works on either pullable or listenable sources.\n *\n * `npm install callbag-map`\n *\n * Example:\n *\n *     const fromIter = require('callbag-from-iter');\n *     const iterate = require('callbag-iterate');\n *     const map = require('callbag-map');\n *\n *     const source = map(x => x * 0.1)(fromIter([10,20,30,40]));\n *\n *     iterate(x => console.log(x))(source); // 1\n *                                           // 2\n *                                           // 3\n *                                           // 4\n */\n\nconst map = f => source => (start, sink) => {\n  if (start !== 0) return;\n  source(0, (t, d) => {\n    sink(t, t === 1 ? f(d) : d)\n  });\n};\n\nmodule.exports = map;\n","/**\n * callbag-scan\n * ------------\n *\n * Callbag operator that combines consecutive values from the same source.\n * It's essentially like array `.reduce`, but delivers a new accumulated value\n * for each value from the callbag source. Works on either pullable or\n * listenable sources.\n *\n * `npm install callbag-scan`\n *\n * Example:\n *\n *     const fromIter = require('callbag-from-iter');\n *     const iterate = require('callbag-iterate');\n *     const scan = require('callbag-scan');\n *\n *     const iterSource = fromIter([1,2,3,4,5]);\n *     const scanned = scan((prev, x) => prev + x, 0)(iterSource);\n *\n *     scanned(0, iterate(x => console.log(x))); // 1\n *                                               // 3\n *                                               // 6\n *                                               // 10\n *                                               // 15\n */\n\nfunction scan(reducer, seed) {\n  let hasAcc = arguments.length === 2;\n  return source => (start, sink) => {\n    if (start !== 0) return;\n    let acc = seed;\n    source(0, (t, d) => {\n      if (t === 1) {\n        acc = hasAcc ? reducer(acc, d) : ((hasAcc = true), d);\n        sink(1, acc);\n      } else sink(t, d);\n    });\n  };\n}\n\nmodule.exports = scan;\n","const flatten = source => (start, sink) => {\n  if (start !== 0) return;\n  const exists = x => typeof x !== 'undefined';\n  const absent = x => typeof x === 'undefined';\n  const noop = () => {};\n  let outerEnded = false;\n  let outerTalkback;\n  let innerTalkback;\n  function talkback(t) {\n    if (t === 1) (innerTalkback || outerTalkback || noop)(1);\n    if (t === 2) {\n      innerTalkback && innerTalkback(2);\n      outerTalkback && outerTalkback(2);\n    }\n  }\n  source(0, (T, D) => {\n    if (T === 0) {\n      outerTalkback = D;\n      sink(0, talkback);\n    } else if (T === 1) {\n      const innerSource = D;\n      if (innerTalkback) innerTalkback(2);\n      innerSource(0, (t, d) => {\n        if (t === 0) {\n          innerTalkback = d;\n          innerTalkback(1);\n        } else if (t === 1) sink(1, d);\n        else if (t === 2 && absent(d)) {\n          if (outerEnded) sink(2);\n          else {\n            innerTalkback = void 0;\n            outerTalkback(1);\n          }\n        }\n        else if (t === 2 && exists(d)) sink(2, d);\n      });\n    } else if (T === 2 && absent(D)) {\n      if (!innerTalkback) sink(2);\n      else outerEnded = true;\n    } else if (T === 2 && exists(D)) sink(2, D);\n  });\n};\n\nmodule.exports = flatten;\n","const take = max => source => (start, sink) => {\n  if (start !== 0) return;\n  let taken = 0;\n  let sourceTalkback;\n  function talkback(t, d) {\n    if (taken < max) sourceTalkback(t, d);\n  }\n  source(0, (t, d) => {\n    if (t === 0) {\n      sourceTalkback = d;\n      sink(0, talkback);\n    } else if (t === 1) {\n      if (taken < max) {\n        taken++;\n        sink(t, d);\n        if (taken === max) {\n          sink(2);\n          sourceTalkback(2);\n        }\n      }\n    } else {\n      sink(t, d);\n    }\n  });\n};\n\nmodule.exports = take;\n","const skip = max => source => (start, sink) => {\n  if (start !== 0) return;\n  let skipped = 0;\n  let talkback;\n  source(0, (t, d) => {\n    if (t === 0) {\n      talkback = d;\n      sink(t, d);\n    } else if (t === 1) {\n      if (skipped < max) {\n        skipped++;\n        talkback(1);\n      } else sink(t, d);\n    } else {\n      sink(t, d);\n    }\n  });\n};\n\nmodule.exports = skip;\n","/**\n * callbag-filter\n * --------------\n *\n * Callbag operator that conditionally lets data pass through. Works on either\n * pullable or listenable sources.\n *\n * `npm install callbag-filter`\n *\n * Example:\n *\n *     const fromIter = require('callbag-from-iter');\n *     const iterate = require('callbag-iterate');\n *     const filter = require('callbag-filter');\n *\n *     const source = filter(x => x % 2)(fromIter([1,2,3,4,5]));\n *\n *     iterate(x => console.log(x))(source); // 1\n *                                           // 3\n *                                           // 5\n */\n\nconst filter = condition => source => (start, sink) => {\n  if (start !== 0) return;\n  let talkback;\n  source(0, (t, d) => {\n    if (t === 0) {\n      talkback = d;\n      sink(t, d);\n    } else if (t === 1) {\n      if (condition(d)) sink(t, d);\n      else talkback(1);\n    }\n    else sink(t, d);\n  });\n};\n\nmodule.exports = filter;\n","/**\n * callbag-merge\n * -------------\n *\n * Callbag factory that merges data from multiple callbag sources. Works well\n * with listenable sources, and while it may work for some pullable sources,\n * it is only designed for listenable sources.\n *\n * `npm install callbag-merge`\n *\n * Example:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const merge = require('callbag-merge');\n *\n *     const source = merge(interval(100), interval(350));\n *\n *     forEach(x => console.log(x))(source); // 0\n *                                           // 1\n *                                           // 2\n *                                           // 0\n *                                           // 3\n *                                           // 4\n *                                           // 5\n *                                           // ...\n */\n\nfunction merge(...sources) {\n  return (start, sink) => {\n    if (start !== 0) return;\n    const n = sources.length;\n    const sourceTalkbacks = new Array(n);\n    let startCount = 0;\n    let endCount = 0;\n    const talkback = t => {\n      if (t === 0) return;\n      for (let i = 0; i < n; i++) sourceTalkbacks[i] && sourceTalkbacks[i](t);\n    };\n    for (let i = 0; i < n; i++) {\n      sources[i](0, (t, d) => {\n        if (t === 0) {\n          sourceTalkbacks[i] = d;\n          if (++startCount === 1) sink(0, talkback);\n        } else if (t === 2) {\n          sourceTalkbacks[i] = void 0;\n          if (++endCount === n) sink(2);\n        } else sink(t, d);\n      });\n    }\n  };\n}\n\nmodule.exports = merge;\n","/**\n * callbag-concat\n * --------------\n *\n * Callbag factory that concatenates the data from multiple (2 or more)\n * callbag sources. It starts each source at a time: waits for the previous\n * source to end before starting the next source. Works with both pullable\n * and listenable sources.\n *\n * `npm install callbag-concat`\n *\n * Example:\n *\n *     const fromIter = require('callbag-from-iter');\n *     const iterate = require('callbag-iterate');\n *     const concat = require('callbag-concat');\n *\n *     const source = concat(fromIter([10,20,30]), fromIter(['a','b']));\n *\n *     iterate(x => console.log(x))(source); // 10\n *                                           // 20\n *                                           // 30\n *                                           // a\n *                                           // b\n */\n\nconst concat = (...sources) => (start, sink) => {\n  if (start !== 0) return;\n  const n = sources.length;\n  if (n === 0) {\n    sink(0, () => {});\n    sink(2);\n    return;\n  }\n  let i = 0;\n  let sourceTalkback;\n  const talkback = (t, d) => {\n    if (t === 1 || t === 2) {\n      sourceTalkback(t, d);\n    }\n  };\n  (function next() {\n    if (i === n) {\n      sink(2);\n      return;\n    }\n    sources[i](0, (t, d) => {\n      if (t === 0) {\n        sourceTalkback = d;\n        if (i === 0) sink(0, talkback);\n        else sourceTalkback(1);\n      } else if (t === 1) {\n        sink(1, d);\n      } else if (t === 2) {\n        i++;\n        next();\n      }\n    });\n  })();\n};\n\nmodule.exports = concat;\n","/**\n * callbag-combine\n * ---------------\n *\n * Callbag factory that combines the latest data points from multiple (2 or\n * more) callbag sources. It delivers those latest values as an array. Works\n * with both pullable and listenable sources.\n *\n * `npm install callbag-combine`\n *\n * Example:\n *\n *     const interval = require('callbag-interval');\n *     const observe = require('callbag-observe');\n *     const combine = require('callbag-combine');\n *\n *     const source = combine(interval(100), interval(350));\n *\n *     observe(x => console.log(x))(source); // [2,0]\n *                                           // [3,0]\n *                                           // [4,0]\n *                                           // [5,0]\n *                                           // [6,0]\n *                                           // [6,1]\n *                                           // [7,1]\n *                                           // [8,1]\n *                                           // ...\n */\n\nconst EMPTY = {};\n\nconst combine = (...sources) => (start, sink) => {\n  if (start !== 0) return;\n  const n = sources.length;\n  if (n === 0) {\n    sink(0, () => {});\n    sink(1, []);\n    sink(2);\n    return;\n  }\n  let Ns = n; // start counter\n  let Nd = n; // data counter\n  let Ne = n; // end counter\n  const vals = new Array(n);\n  const sourceTalkbacks = new Array(n);\n  const talkback = (t, d) => {\n    if (t !== 2) return;\n    for (let i = 0; i < n; i++) sourceTalkbacks[i](2);\n  };\n  sources.forEach((source, i) => {\n    vals[i] = EMPTY;\n    source(0, (t, d) => {\n      if (t === 0) {\n        sourceTalkbacks[i] = d;\n        if (--Ns === 0) sink(0, talkback);\n      } else if (t === 1) {\n        const _Nd = !Nd ? 0 : vals[i] === EMPTY ? --Nd : Nd;\n        vals[i] = d;\n        if (_Nd === 0) {\n          const arr = new Array(n);\n          for (let j = 0; j < n; ++j) arr[j] = vals[j];\n          sink(1, arr);\n        }\n      } else if (t === 2) {\n        if (--Ne === 0) sink(2);\n      } else {\n        sink(t, d);\n      }\n    });\n  });\n};\n\nmodule.exports = combine;\n","const share = source => {\n  let sinks = [];\n  let sourceTalkback;\n  return function shared(start, sink) {\n    if (start !== 0) return;\n    sinks.push(sink);\n    if (sinks.length === 1) {\n      source(0, (t, d) => {\n        if (t === 0) sourceTalkback = d;\n        else for (let s of sinks.slice(0)) s(t, d);\n        if (t === 2) sinks = [];\n      });\n    }\n    sink(0, (t, d) => {\n      if (t === 0) return;\n      if (t === 2) {\n        const i = sinks.indexOf(sink);\n        if (i > -1) sinks.splice(i, 1);\n        if (!sinks.length) sourceTalkback(2);\n      } else {\n        sourceTalkback(t, d);\n      }\n    });\n  }\n}\n\nmodule.exports = share;\n","/**\n * callbag-pipe\n * ------------\n *\n * Utility function for plugging callbags together in chain. This utility\n * actually doesn't rely on Callbag specifics, and is basically the same as\n * Ramda's `pipe` or lodash's `flow`. Anyway, this exists just to play nicely\n * with the ecosystem, and to facilitate the import of the function.\n *\n * `npm install callbag-pipe`\n *\n * Example:\n *\n * Create a source with `pipe`, then pass it to a `forEach`:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     const source = pipe(\n *       combine(interval(100), interval(350)),\n *       map(([x, y]) => `X${x},Y${y}`),\n *       take(10)\n *     );\n *\n *     forEach(x => console.log(x))(source); // X2,Y0\n *                                           // X3,Y0\n *                                           // X4,Y0\n *                                           // X5,Y0\n *                                           // X6,Y0\n *                                           // X6,Y1\n *                                           // X7,Y1\n *                                           // X8,Y1\n *                                           // X9,Y1\n *                                           // X9,Y2\n *\n *\n * Or use `pipe` to go all the way from source to sink:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       map(([x, y]) => `X${x},Y${y}`),\n *       take(10),\n *       forEach(x => console.log(x))\n *     );\n *     // X2,Y0\n *     // X3,Y0\n *     // X4,Y0\n *     // X5,Y0\n *     // X6,Y0\n *     // X6,Y1\n *     // X7,Y1\n *     // X8,Y1\n *     // X9,Y1\n *     // X9,Y2\n *\n *\n * Nesting\n * -------\n *\n * To use pipe inside another pipe, you need to give the inner pipe an\n * argument, e.g. `s => pipe(s, ...`:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       s => pipe(s,\n *         map(([x, y]) => `X${x},Y${y}`),\n *         take(10)\n *       ),\n *       forEach(x => console.log(x))\n *     );\n *\n *\n * This means you can use pipe to create a new operator:\n *\n *     const mapThenTake = (f, amount) =>\n *       s => pipe(s, map(f), take(amount));\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       mapThenTake(([x, y]) => `X${x},Y${y}`, 10),\n *       forEach(x => console.log(x))\n *     );\n *\n */\n\nfunction pipe(...cbs) {\n  let res = cbs[0];\n  for (let i = 1, n = cbs.length; i < n; i++) res = cbs[i](res);\n  return res;\n}\n\nmodule.exports = pipe;\n","module.exports = {\n  forEach: require('callbag-for-each'),\n  fromObs: require('callbag-from-obs'),\n  fromIter: require('callbag-from-iter'),\n  fromEvent: require('callbag-from-event'),\n  fromPromise: require('callbag-from-promise'),\n  interval: require('callbag-interval'),\n  map: require('callbag-map'),\n  scan: require('callbag-scan'),\n  flatten: require('callbag-flatten'),\n  take: require('callbag-take'),\n  skip: require('callbag-skip'),\n  filter: require('callbag-filter'),\n  merge: require('callbag-merge'),\n  concat: require('callbag-concat'),\n  combine: require('callbag-combine'),\n  share: require('callbag-share'),\n  pipe: require('callbag-pipe')\n};\n\n","import {forEach, fromEvent, map, filter, pipe} from 'callbag-basics';\n\nconst COLORS = ['#a8e6cf', '#dcedc1', '#ffd3b6', '#ffaaa5', '#ff8b94']\nconst SQUARE_COUNT = 50\n\n// Add more Squares as necessary\n\nconst squares = document.getElementById(\"home\")\nconst addRow = (parent, rowCount) => {\n  const row = document.createElement(\"div\")\n  row.setAttribute(\"class\", \"row\")\n\n  const testSquare = document.createElement(\"div\")\n  testSquare.setAttribute(\"class\", \"square\")\n\n  Array(5).fill(undefined).forEach((_, i) => {\n    const newSquare = testSquare.cloneNode()\n    const idNumber = (rowCount-1)*5+i+1\n    newSquare.setAttribute(\"id\", `square-${idNumber}`)\n    row.appendChild(newSquare)\n  })\n  parent.appendChild(row)\n}\n\nconst addRows = (parent, rowsToAdd) => {\n  let rowCount = 3\n  Array(rowsToAdd).fill(undefined).forEach(() => {\n    rowCount++\n    addRow(parent, rowCount)\n  })\n}\n\nconst rowsToAdd = SQUARE_COUNT/5 - 3\naddRows(squares, rowsToAdd)\n\n// Random Colors\n\nconst squareIds = Array(SQUARE_COUNT).fill(undefined)\n  .map((_, i) => `square-${i + 1}`)\n\nconst rgbToHex = (rgb) => {\n  if (/^#[0-9A-F]{6}$/i.test(rgb)) return rgb;\n\n  rgb = rgb.match(/^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/);\n  function hex(x) {\n      return (\"0\" + parseInt(x).toString(16)).slice(-2);\n  }\n  return \"#\" + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]);\n}\n\n\nconst setBackgroundColor = (id, random = Math.random()) => {\n  const el = document.getElementById(id)\n  const backgroundColor = rgbToHex(el.style.backgroundColor || COLORS[0])\n  const otherColors = COLORS.filter(c => c !== backgroundColor)\n  \n  const newColor = otherColors[Math.floor(random * otherColors.length)]\n\n  el.style.backgroundColor = newColor;\n}\n\npipe(\n  fromEvent(document, 'mouseover'),\n  filter(ev => squareIds.includes(ev.target.id)),\n  map(ev => ev.target.id),\n  forEach(setBackgroundColor)\n)\n\n","import {forEach, fromEvent, map, filter, pipe} from 'callbag-basics';\n\nconst PAGE_IDS = ['home', 'about', 'signup']\nconst pageButtonClasses = PAGE_IDS.map(id => `${id}-bttn`)\n\nconst setHash = id => {\n  window.location.hash = id\n}\n\nconst displayContent = hash => {\n  const id = hash ? hash.substr(1) : 'home'\n  document.getElementById(id).classList.remove('hide')\n  PAGE_IDS\n    .filter(i => i !== id)\n    .forEach(i => document.getElementById(i).classList.add('hide'))\n}\n\npipe(\n  fromEvent(document, 'click'),\n  filter(ev => pageButtonClasses.includes(ev.target.id)),\n  map(ev => ev.target.id.split('-')[0]),\n  forEach(setHash)\n)\n\npipe(\n  fromEvent(window, 'hashchange'),\n  forEach(() => displayContent(window.location.hash))\n)\n","import squares from './squares.js'\nimport nav from './nav.js'\n"]}